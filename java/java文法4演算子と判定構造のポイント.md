# 演算子と判定構造のポイント

## まずは演算子と前置と後置

前置（⭕️⭕️a）
演算子を変数の前に置く書き方。
①インクリメント(デクリメント)してから
②代入する

後置(a⭕️⭕️)
演算子を変数の後に置く書き方。前置とは逆に、
①代入してから
②インクリメント(デクリメント)する

[前置と後置](https://qiita.com/uzura56/items/641b61368b6d8624a9c4)



<details>
  <summary></summary>
  
```

class java2_6 {

public static void main (String[] args) {
int a = 3;
int b =  a += 5;
System.out.println(a + b); //正解は16
⭐️加算代入演算子
a=3
int b = a += 5;で、aに5を加えた結果をaに再代入し、その新しい値をbにも代入。これにより、aの値は8、ｂの値も８
aとbは共に8なので、出力は16



int c = 10;
int d = c++; 
System.out.println(c + d);//正解は21
⭐️後置インクリメント演算子
int c = 10;
int d = c++;では、cの現在の値をdに代入した後、cの値を1増やす。この操作後、cは11、dは10
結果は21


int e = 10;
int f = ++e + 10; 
System.out.println(e +f);//３２
⭐️前置インクリメント演算子
int e = 10;
int f = ++e + 10;では、eの値を1増やしてからその新しい値（11）に10を加え、その結果（21）をfに代入します。
つまり。e= 11 f= 21
結果は32


int g = 10;
int h = g++ + 10;
System.out.println(g + h);
⭐️後置インクリメントと加算
int g = 10;
int h = g++ + 10;では、gの現在の値に10を加えたものをhに代入した後、gの値を1増やす。
つまり　g=11 h=20
結果は31


int aa = 10;
int bb = aa++;
System.out.println(bb++ + aa++ - --aa);
⭐️複合したインクリメントとデクリメントの操作
int aa = 10;
int bb = aa++;で、aaの値をbbに代入した後、aaを1増やす。この時点ではaa=11 bb=10

System.out.println(bb++ + aa++ - --aa);について
bb++は後置インクリメント。bbの現在の値（10）に値を1増やすが、後置なので式の評価後に発生するため、この時点の結果は10。
式の評価後は11

aa++も後置インクリメント。aaの現在の値（11）に値を1増やすが、後置なので式の評価後に発生するため、この時点の結果は11。
式の評価後は１２

--aaは前置デクリメント。aaの値を1減らしてからその値（11に減らされた後の値）を式の評価に使用
⭐️つまり、aa++の後でaaは12になっていたが、--aaによって11に減少
式の評価後は１１

式の組み合わせは、bb++ + aa++ - --aaは10 + 11 - 11
結果は10



int a = 10;
int b = a++ + a + a-- - a-- + ++a;
System.out.println(b );
⭐️
int a = 10
a++ (aの値は11になりますが、式には10が使用されます。)
a (既に11に増えているので、この時点での値は11です。)
a-- (aの値は10になりますが、式には11が使用されます。)
a-- (aは9になりますが、式には10が使用されます。)
++a (aの値を式の評価前に1増やします。aの値は9から10に増え、この増えた値が式に使用されます。)
10 + 11 + 11 - 10 + 10

}
}
```

</details>

## 論理演算子

[関係演算子](https://qiita.com/naitoyuma/items/638021fae10f13368cfc)


class java2_6 {

public static void main (String[] args) {
int a = 10;

int b = 10;

if(10 < a && 10 < ++b){

a++;

}

System.out.println( a + b );
}
}


<details>
  <summary>条件文の中身</summary>
  
```
if(10 < a && 10 < ++b){
    a++;
}

① 2つの条件が両方ともtrueで中の処理（a++;）を実行する
② 条件10 < aはaが10より大きいかどうかを評価しますが、aは10に初期化されているため、この条件はfalse（偽）。この時点で
処理は実行されない
③ 10 < ++bはbの値を1増やした後（つまりbは11になります）、それが10より大きいかどうかを評価します
④ System.out.println( a + b );より合計は10 + 11 = 21
```

</details>

## 同一性と同値
同一性:
同一性は、2つのオブジェクト参照が同じオブジェクトを指しているかどうかを判定します。
== 演算子は、オブジェクトの同一性を判定するために使用されます。
例えば、object1 == object2 は、object1とobject2がメモリ上で同じオブジェクトを指している場合に true を返します。
同値性:
同値性は、2つのオブジェクトが論理的に等しい内容を持っているかどうかを判定します。
equals() メソッドは、オブジェクトの同値性を判定するために使用されます。
object1.equals(object2) は、object1 と object2 の内容が論理的に等しい場合に true を返します。
ダブルクオテーション（””）で文字列を作成したらコンスタントプールが作成されるため同一性になります。そのため、 == で同じ文字列か比較することができます。明示的にコンスタントプールを作成したい場合はintern()を使用します。


